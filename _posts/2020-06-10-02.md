---
layout:     post
title:      栈和队列
subtitle:   
date:       2020-06-10
author:     小骆驼
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据结构
    - 算法
---
# 引言
本篇文章主要参考的是我本科期间学习的`数据结构`课程，对栈和队列的定义以及基本运算进行了简单的介绍。在这边文章中涉及到的类型定义以及基本运算的代码都用C语言表示。

栈和队列是两种特殊的线性表，其逻辑结构和线性表相同。比起线性表其运算受限制，故又称它们为运算受限的线性表。栈和队列应用在各种程序设计中，尤其栈的应用更广。

# 栈
## 定义
栈（Stack）是限制仅在表的`一端`进行插入和删除运算的线性表。(1)通常称插入、删除的这一端为`栈顶（Top`），另一端称为`栈底（Bottom）`。
(2)当表中没有元素时称为`空栈`。(3)栈的插入操作被形象地称为`进栈`或`入栈`，删除操作称为`出栈`或`退栈`。
栈又称为`后进先出`的线性表。简称为LIFO表。

根据存储方式的不同，栈可以分为顺序栈和链栈。


## 顺序栈
顺序栈利用一组`地址连续`的存储单元依次存放自栈底到栈顶的数据元素。

### 顺序栈的类型定义

```
#define TRUE 1
#define FALSE 0
#define Stack_Size 50

 typedef struct
{    StackElementType  elem[Stack_Size];  
      /* 一维数组*/
      int  top;                          
      /*用来存放栈顶元素的下标*/
}SeqStack;
```

顺序栈中的栈底位置不变，栈顶位置随着进栈和退栈不断变化，栈顶指针top指示当前栈顶位置。

### 顺序栈的基本运算
置栈空：
```
  void InitStack（SeqStack *S）
  {//将顺序栈置空
     S->top=-1;
    } 
```

判栈空
```
  int StackEmpty（SeqStack *S）
  { 
     /*判栈S为空栈时返回值为真，反之为假*/
     return S->top==-1;
   }
```

判栈满
```
  int StackFull（SeqStack *S）
  {
  /*判栈S为满时返回真，否则返回假*/
       return S->top==StackSize-1;
  }
```
进栈

进栈时，需要将S-＞top加1

注意：
1. S-＞top==StackSize-1表示栈满
2. "上溢"现象-当栈满时，再做进栈运算产生空间溢出的现象。应设法避免。

```
void Push（SeqStack *S，DataType x）
{
 if (StackFull(S))
 Error(“Stack overflow”); //上溢，退出运行
 S->data[++S->top]=x;//栈顶指针加1后将x入栈
}
```

退栈

退栈时，需将S-＞top减1

注意：
1. S-＞top<0表示空栈
2. "下溢"现象——当栈空时，做退栈运算产生的溢出现象。
下溢是正常现象，常用作程序控制转移的条件。
```
DataType Pop（S）
{
  if(StackEmpty(S))
    Error(“Stack underflow”); //下溢，退出运行
  return S->data[S->top--];//栈顶元素返回后将栈顶指针减1
}
```

取栈顶元素
```
DataType StackTop（S）
{
    if(StackEmpty(S))
        Error("Stack is empty");
    return S->data[S->top];
}
```

## 链栈
链栈是采用链表作为存储结构实现的栈，是`线性链表`的特例。因为栈的插入和删除操作仅限制在`表头`位置进行，所以链表的`表头指针`就作为`栈顶指针`。 
### 链栈的类型定义

```
  typedef struct stacknode{
      DataType data
      struct stacknode *next
  }StackNode;

  StackNode *head=NULL;

  typedef struct{
      StackNode *top;  //栈顶指针
  }LinkStack;

```

### 链栈的基本运算
置栈空
```
void InitStack(LinkStack *S)
{
  S->top=NULL;
}
```

判栈空
```
int StackEmpty(LinkStack *S)
{
  return S->top==NULL;
}
```

进栈
```
void Push(LinkStack *S,DataType x)
{//将元素x插入链栈头部
     StackNode *p=(StackNode *)malloc(sizeof(StackNode));
     if(p==NULL)
     { printf(“内存空间不够分配”);
        exit(0);//return 
     }  //健壮
     p->data=x;
     p->next=S->top;//将新结点*p插入链栈头部
     S->top=p; 
}

```
退栈
```
DataType Pop(LinkStack *S)
{
    DataType x;
    StackNode *p=S->top;//保存栈顶指针
    if(StackEmpty(S))
        Error("Stack underflow.");  //下溢
    x=p->data;  //保存栈顶结点数据
    S->top=p->next;  //将栈顶结点从链上摘下
    free(p);
    return x;
}
```

取栈顶元素
```
DataType StackTop(LinkStack *S)
{
  if(StackEmpty(S))
      Error("Stack is empty.")
  return S->top->data;
}
```

# 队列
队列是一种特殊的线性表，限定插入和删除操作分别在表的两端进行。
## 队列的定义

## 顺序队列

## 链队列
